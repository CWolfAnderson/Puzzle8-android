// PuzzleBoard

public class PuzzleBoard {

    private int steps;
    private PuzzleBoard previousBoard ;
    private static final int NUM_TILES = 3;
    private static final int[][] NEIGHBOUR_COORDS = {
            { -1, 0 },
            { 1, 0 },
            { 0, -1 },
            { 0, 1 }
    };
    private ArrayList<PuzzleTile> tiles;

    PuzzleBoard(Bitmap bitmap, int parentWidth) {

        Bitmap source = Bitmap.createScaledBitmap(bitmap, parentWidth, parentWidth, true);

        steps = 0;
        previousBoard = null;
        tiles = new ArrayList<PuzzleTile>();

        int blockWidth = source.getWidth() / 3;

        int xCorner = 0;
        int yCorner = 0;

        for (int index = 0; index < 8; index++) {
            xCorner = (index % 3) * blockWidth;
            yCorner = (index / 3) * blockWidth;

            Bitmap temp = Bitmap.createBitmap(source, xCorner, yCorner, blockWidth, blockWidth);
            tiles.add(new PuzzleTile(temp, index));
        }
        tiles.add(null);
    }

    PuzzleBoard(PuzzleBoard otherBoard) {
        tiles = (ArrayList<PuzzleTile>) otherBoard.tiles.clone();
        steps = otherBoard.getSteps() + 1;
        previousBoard = otherBoard;
    }

    public void reset() {
        // Nothing for now but you may have things to reset once you implement the solver.
    }

    @Override
    public boolean equals(Object o) {
        if (o == null)
            return false;
        return tiles.equals(((PuzzleBoard) o).tiles);
    }

    public void draw(Canvas canvas) {
        if (tiles == null) {
            return;
        }
        for (int i = 0; i < NUM_TILES * NUM_TILES; i++) {
            PuzzleTile tile = tiles.get(i);
            if (tile != null) {
                tile.draw(canvas, i % NUM_TILES, i / NUM_TILES);
            }
        }
    }

    public boolean click(float x, float y) {
        for (int i = 0; i < NUM_TILES * NUM_TILES; i++) {
            PuzzleTile tile = tiles.get(i);
            if (tile != null) {
                if (tile.isClicked(x, y, i % NUM_TILES, i / NUM_TILES)) {
                    return tryMoving(i % NUM_TILES, i / NUM_TILES);
                }
            }
        }
        return false;
    }

    public boolean resolved() {
        for (int i = 0; i < NUM_TILES * NUM_TILES - 1; i++) {
            PuzzleTile tile = tiles.get(i);
            if (tile == null || tile.getNumber() != i)
                return false;
        }
        return true;
    }

    private int XYtoIndex(int x, int y) {
        return x + y * NUM_TILES;
    }

    protected void swapTiles(int i, int j) {
        PuzzleTile temp = tiles.get(i);
        tiles.set(i, tiles.get(j));
        tiles.set(j, temp);
    }

    private boolean tryMoving(int tileX, int tileY) {
        for (int[] delta : NEIGHBOUR_COORDS) {
            int nullX = tileX + delta[0];
            int nullY = tileY + delta[1];
            if (nullX >= 0 && nullX < NUM_TILES && nullY >= 0 && nullY < NUM_TILES &&
                    tiles.get(XYtoIndex(nullX, nullY)) == null) {
                swapTiles(XYtoIndex(nullX, nullY), XYtoIndex(tileX, tileY));
                return true;
            }

        }
        return false;
    }

    public ArrayList<PuzzleBoard> neighbours() {

        ArrayList<PuzzleBoard> validMoves = new ArrayList<PuzzleBoard>();

        int index = 0;
        int nullX = 0;
        int nullY = 0;

        for (; index < tiles.size(); index++) {
            if (tiles.get(index) == null) {
                nullX = index % 3;
                nullY = index / 3;
                break;
            }
        }

        if (nullX + NEIGHBOUR_COORDS[0][0] > - 1) {
            PuzzleBoard copy = new PuzzleBoard(this);
            copy.swapTiles(index, index - 1);
            validMoves.add(copy);
        }
        if (nullX + NEIGHBOUR_COORDS[1][0] < 3) {
            PuzzleBoard copy = new PuzzleBoard(this);
            copy.swapTiles(index, index + 1);
            validMoves.add(copy);
        }
        if (nullY + NEIGHBOUR_COORDS[2][1] > - 1) {
            PuzzleBoard copy = new PuzzleBoard(this);
            copy.swapTiles(index, index - 3);
            validMoves.add(copy);
        }
        if (nullY + NEIGHBOUR_COORDS[3][1] < 3) {
            PuzzleBoard copy = new PuzzleBoard(this);
            copy.swapTiles(index, index + 3);
            validMoves.add(copy);
        }

        return validMoves;
    }

    public int priority() {

        int accumulator = 0;
        int defaultIndex;

        int xGoal = 0;
        int yGoal = 0;

        int xCurrent = 0;
        int yCurrent = 0;

        for(int currentIndex = 0; currentIndex < this.tiles.size(); currentIndex++) {

            if (tiles.get(currentIndex) != null) {

                defaultIndex = tiles.get(currentIndex).getNumber();

                xCurrent = currentIndex % 3;
                yCurrent = currentIndex / 3;

                xGoal = defaultIndex % 3;
                yGoal = defaultIndex / 3;
            }

            accumulator += Math.abs(xGoal - xCurrent) + Math.abs(yGoal - yCurrent);
        }
        return accumulator + steps;
    }

    public int getSteps() {
        return steps;
    }
    public void setSteps(int steps) {
        this.steps = steps;
    }

    public PuzzleBoard getPreviousBoard() {
        return previousBoard;
    }

}















// PuzzleActivity

public class PuzzleActivity extends AppCompatActivity {

    static final int REQUEST_IMAGE_CAPTURE = 1;
    private Bitmap imageBitmap = null;
    private PuzzleBoardView boardView;

    @Override
    protected void onCreate(Bundle savedInstanceState) {
        super.onCreate(savedInstanceState);
        setContentView(R.layout.activity_puzzle);

        RelativeLayout container = (RelativeLayout) findViewById(R.id.puzzle_container);
        boardView = new PuzzleBoardView(this);

        // Some setup of the view.
        boardView.setLayoutParams(new RelativeLayout.LayoutParams(RelativeLayout.LayoutParams.MATCH_PARENT, RelativeLayout.LayoutParams.MATCH_PARENT));
        container.addView(boardView);
    }

    @Override
    public boolean onCreateOptionsMenu(Menu menu) {
        // Inflate the menu; this adds items to the action bar if it is present.
        getMenuInflater().inflate(R.menu.menu_puzzle, menu);
        return true;
    }

    @Override
    public boolean onOptionsItemSelected(MenuItem item) {
        // Handle action bar item clicks here. The action bar will
        // automatically handle clicks on the Home/Up button, so long
        // as you specify a parent activity in AndroidManifest.xml.
        int id = item.getItemId();

        //noinspection SimplifiableIfStatement
        if (id == R.id.action_settings) {
            return true;
        }

        return super.onOptionsItemSelected(item);
    }

    @Override
    protected void onActivityResult(int requestCode, int resultCode, Intent data) {

        if (requestCode == REQUEST_IMAGE_CAPTURE && resultCode == RESULT_OK) {
            Bundle extras = data.getExtras();
            imageBitmap = (Bitmap) extras.get("data");
            boardView.initialize(imageBitmap, null);
        }
    }

    public void dispatchTakePictureIntent(View view) {
        Intent cameraCapture = new Intent(MediaStore.ACTION_IMAGE_CAPTURE);
        startActivityForResult(cameraCapture, REQUEST_IMAGE_CAPTURE);
    }

    public void shuffleImage(View view) {
        boardView.shuffle();
    }

    public void solve(View view) {
        boardView.solve();
    }
}















// PuzzleBoardComparator

public class PuzzleBoardComparator implements Comparator<PuzzleBoard> {

    @Override
    public int compare(PuzzleBoard a, PuzzleBoard b) {
        if (a == null || b == null) throw  new NullPointerException();
        return a.priority() - b.priority();
    }
}


















// PuzzleBoardView

public class PuzzleBoardView extends View {
    public static final int NUM_SHUFFLE_STEPS = 40;
    private Activity activity;
    private PuzzleBoard puzzleBoard;
    private ArrayList<PuzzleBoard> animation;
    private Random random = new Random();

    public PuzzleBoardView(Context context) {
        super(context);
        activity = (Activity) context;
        animation = null;
    }

    public void initialize(Bitmap imageBitmap, View parent) {
        int width = getWidth();
        puzzleBoard = new PuzzleBoard(imageBitmap, width);
        invalidate();
    }

    @Override
    protected void onDraw(Canvas canvas) {
        super.onDraw(canvas);
        if (puzzleBoard != null) {
            if (animation != null && animation.size() > 0) {
                puzzleBoard = animation.remove(0);
                puzzleBoard.draw(canvas);
                if (animation.size() == 0) {
                    animation = null;
                    puzzleBoard.reset();
                    Toast toast = Toast.makeText(activity, "Solved! ", Toast.LENGTH_LONG);
                    toast.show();
                } else {
                    this.postInvalidateDelayed(500);
                }
            } else {
                puzzleBoard.draw(canvas);
            }
        }
    }

    public void shuffle() {

        ArrayList<PuzzleBoard> possibleMoves;
        int randMove;

        if (animation == null && puzzleBoard != null) {

            for(int count = 0; count < NUM_SHUFFLE_STEPS; count++) {
                possibleMoves = puzzleBoard.neighbours();
                randMove = random.nextInt(possibleMoves.size());
                puzzleBoard = possibleMoves.get(randMove);
            }
            invalidate();
        }
    }

    @Override
    public boolean onTouchEvent(MotionEvent event) {
        if (animation == null && puzzleBoard != null) {
            switch(event.getAction()) {
                case MotionEvent.ACTION_DOWN:
                    if (puzzleBoard.click(event.getX(), event.getY())) {
                        invalidate();
                        if (puzzleBoard.resolved()) {
                            Toast toast = Toast.makeText(activity, "Congratulations!", Toast.LENGTH_LONG);
                            toast.show();
                        }
                        return true;
                    }
            }
        }
        return super.onTouchEvent(event);
    }

    // using A* search
    public void solve() {

        PriorityQueue<PuzzleBoard> boardStates = new PriorityQueue<PuzzleBoard>(1,new PuzzleBoardComparator());
        ArrayList<PuzzleBoard> solution;
        PuzzleBoard currentBoard = null;

        try {
            puzzleBoard.setSteps(0);
            boardStates.add(puzzleBoard);

            while (!boardStates.isEmpty()) {

                currentBoard = boardStates.poll();

                if (!currentBoard.resolved()) {

                    ArrayList<PuzzleBoard> neighboursMoves = currentBoard.neighbours();

                    for(PuzzleBoard move: neighboursMoves) {=
                        if (!currentBoard.getPreviousBoard().equals(move)) boardStates.add(move);
                    }
                }
                else {
                    break;
                }
            }

            Log.d("test", "steps to solution: " + currentBoard.getSteps());
            solution = new ArrayList<PuzzleBoard>();

            for(int countdown = currentBoard.getSteps(); 0 < countdown ;countdown--) {
                solution.add(currentBoard);
                currentBoard = currentBoard.getPreviousBoard();
            }

            Collections.reverse(solution);
            animation = solution;
            invalidate();
        }
        catch (Exception e) {
            e.printStackTrace();
        }
    }
}